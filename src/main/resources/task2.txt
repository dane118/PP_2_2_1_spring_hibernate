- Каждая сущность должна иметь свой слой взаимодействия с БД, который отвечает
за сохранение, обновление, удаление и получение данных для этой сущности. При
твоей логике должен быть слой dao и service для Car с методом сохранения. Так же
можно было бы воспользоваться аннотацией @MapsId

- В рамках этой задачи ок, но рекомендуется всегда использовать FetchType.LAZY
 для связанных сущностей, чтобы избежать жадной загрузки связанных данных
 (а значит лишних запросов в БД), когда в бизнес логике эти данные не используются.
  При данной стратегии данные будут загружаться при первом обращении. Но нужно быть
  внимательным при запросах, так как это может привести к проблеме n + 1, а также к
  исключению LazyInitializationException

- Включи свойство hibernate.format_sql=true и увидишь отформатированный SQL
в консоли. Посмотри на количество запросов с разной стратегией загрузки связанной
 сущности, с использованием JOIN FETCH и без него в запросе
Пакет model

- импортируешь весь пакет javax.persistence
Пакет dao
Класс UserDaoImpl

- в рамках метода getUserByCar используй JOIN FETCH и таким образом сможешь
реализовать выборку за один запрос. Не возвращай из метода null, для безопасной работы с null используй Optional